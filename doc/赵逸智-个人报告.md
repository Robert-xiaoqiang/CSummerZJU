# 赵逸智-个人报告

### 分工

* 第一轮迭代我主要负责View层，完成View层的框架。
* 第二轮迭代我同样负责View层，主要完成界面的美化和显示问题的处理。
* 第三轮迭代我加入Model、ViewModel层的工作，添加了Huffman Tree。

-------------------

### 第一轮迭代工作

* **设计任务**
  * 界面设计：实现程序的初始界面与绘图界面，其中初始界面主要供用户选择其希望演示的数据结构，绘图界面进行实际的演示操作。
  * 按钮设计：需实现含有以下四种功能的按钮
    * 初始界面中选择不同数据结构类型进入绘图界面
    * 从绘图界面中返回到初始界面(Return)
    * 在绘图界面中进行插入结点(Insert)、删除结点(Delete)、查找结点(Find)、清除数据的操作(Clear)
    * 退出程序(Exit)

* **设计方案**

  本轮迭代的设计方案通过分别介绍所实现的类而简单展开。

  * DSWidget
    * 继承：Qt库中的类QWidget
    * 功能：DSWidget为View层各界面的通用父类，在QWidget上添加一些通用功能后形成。其主要功能为便于统一项目中各界面的设计风格，同时减少代码重复率。
  * StartMenu
    * 继承：DSWidget
    * 功能：项目启动后初始界面，用户可在此处选择各种数据结构进入绘图界面，也可以选择退出程序。
  * DrawWindow
    * 继承：DSWidget
    * 功能：绘图界面，用户可在此处选择对数据结构进行各种操作，也可以选择回到初始界面。
  * DSView
    * 功能：DSView为View层的顶层类，其对View层的各页面与通知的接收器进行封装整合。

---------------------------

### 第二轮迭代工作

* **设计任务**

  美化项目界面，优化显示功能，以提升用户体验。					

* **实现方案**

  * 优化窗口显示和关闭函数

    ​	在切换窗口时，如直接调用Qt的show()和close()函数，可能会由于旧窗口关闭和新窗口打开的时间差造成闪屏的现象。因此，我在DSWidget中添加flashShow()和flashClose()函数，分别实现淡入和淡出效果，用来代替所有的show()和close()函数，也使得程序的打开和关闭更为自然。

    ```
    void flashShow(int duration);
    void flashClose(int duration);
    ```

    ​	其中，参数duration为淡入和淡出动画的持续时间。

  * 添加背景与标志图片

    * 背景图片通过添加Resources的方式添加至项目，需要使用时则使用QPalette添加。
    * 项目的图片标志利用Qt的rc文件并修改项目的.pro文件添加。

  * 统一按钮与标签设计风格

    结合背景图片，按钮的设计风格细节如下。

    ​	设计风格：扁平化

    ​	字体颜色：白色

    ​	背景颜色：透明

    ​	字体：Agency FB 

    ​	字号：20

    ​	鼠标停留效果：字体颜色变为灰色

    ​	鼠标点击效果：字体颜色保持灰色，背景颜色变为半透明的白色

    文字标签的设计风格与此类似，但字号会根据页面布局的不同而有所调整。

  * 最终效果

    经过去除边框、确定窗口大小等其他操作，最终窗口和项目标志的显示效果如下图。

    ![](https://github.com/SummerZJU/CSummerZJU/blob/master/image/View/StartMenu.png)

    ![](https://github.com/SummerZJU/CSummerZJU/blob/master/image/View/DrawWindow.png)

    ![](https://github.com/SummerZJU/CSummerZJU/blob/master/image/View/icon.jpg)

------------------------

### 第三轮迭代工作

* **设计任务**

  设计霍夫曼树及其插入、删除操作。

* **实现方案**

  ​	霍夫曼树继承王晓强同学在第一轮迭代中实现的BaseTree，并直接使用BaseTree的中序和层序遍历函数。但不同之处在于，霍夫曼树须通过一个数组保存树中所有叶结点的key值，而每一次插入或删除，实际上都是对这个数组作插入或删除，再在该数组上建最小堆并通过堆建树的过程。

  ​	下面给出通过数组建树的代码。

  ```
  template <typename T, typename S>
  void HFTree<T, S>::create()
  {
     	step1 根据数组建堆，其中堆中元素个数与数组元素个数相同，每个元素均为仅有一个根结点的霍夫曼树，
     	该根节点的值为数组中的一个值。堆中元素排序顺序为树的根节点的值
  	step2 如果堆中仅剩1个元素，则跳至step6
  	step3 选择堆顶的一棵树
  	step4 再次选择堆顶的一颗树
  	step5 建立一棵新的霍夫曼树，其左子树为step3所选的树，右子树step4所选的树，
  	其根结点的值为左右子结点的值相加，将这棵树加入进堆。
  	step6 此时堆中仅剩一棵树，也即最终得到的霍夫曼树，对这棵树进行层序遍历和中序遍历，
  	以得到便于画出这棵树的参数	
  }
  ```

* 单元测试

  * 测试代码

  ```
     #include "HFTree.h"
     int main()
     {
          HFTree<int> * hft = new HFTree<int>;
          hft->insert(1);
          hft->levelPrint(); //该函数按层序遍历的顺序打印霍夫曼树每个结点的值
          hft->insert(2);
   	    hft->levelPrint();
          hft->insert(5);
          hft->levelPrint();
          hft->insert(13);
          hft->levelPrint();
          hft->erase(1);
          hft->levelPrint();
          hft->erase(13);
          hft->levelPrint();
  
          delete rbt;
          return 0;
     }
  ```

  * 测试结果

    ![](https://github.com/SummerZJU/CSummerZJU/blob/master/image/Model/testHFT.png)

-----------------------------------------------

### 课程心得

​	在上学期，我学习了讲授C++语言的基础课程——面向对象程序设计，课上讲授了C++的各种经典语法和面向对象程序设计的思想；但对于实际工程当中，C++是如何被运用的，我的了解并不多。而在这门课程中，我不仅学习到了C++较新但常用的语法，如智能指针等，还了解并实操了C++编程的MVVM框架。在这种框架下，各部分代码的耦合度得到降低，从而便于各部分的独立开发与独立测试。同时，运用一系列命令与通知的机制，我们也可以使得程序的结构更为清晰和规范。

​	此外，在这门课上，我也学习到了很多合作开发程序的技巧。之前虽然在不少课上也有过多人合作完成项目的经历，但当时我们多通过QQ来上传个人的代码，这不仅会让使整合困难，而且还可能带来新旧重名文件的混淆。而在本课程中，我们使用git进行版本控制，这让工程文件的组织更为有序不易发生混淆，也使得我们能看到项目从建立到完成每一次提交的记录。在持续集成方面，我们组借助了Appveyor平台，这帮助了我们及时检查自己每一轮迭代完成的效果。

--------------------------------------

### 课程建议

​	我们组在课程开始阶段因为没有完全理解MVVM模式，也有没可参考的样例而犯了一些错误，浪费了不少时间。因此，我认为如果能在课程一开始就有可供参考的例程，会给我们带来很大的帮助。
